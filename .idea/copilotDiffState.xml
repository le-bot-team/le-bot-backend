<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/chat/api/openspeech/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/chat/api/openspeech/index.ts" />
              <option name="originalContent" value="import { log } from '@log'&#10;&#10;import {&#10;  CompressionType,&#10;  MessageFlagType,&#10;  MessageType,&#10;  ResponseType,&#10;  SerializationType,&#10;  TtsEventType,&#10;} from './types'&#10;import {&#10;  createAsrRequestData,&#10;  createTtsRequestData,&#10;  parseResponseMessage,&#10;  serializeRequestMessage,&#10;} from './utils'&#10;&#10;export class AsrApi {&#10;  private _connectionPromise: Promise&lt;boolean&gt; | null = null&#10;  private _isReady = false&#10;  private _sequenceNumber = 1&#10;  private _ws: WebSocket | undefined&#10;&#10;  onFinish: ((recognized: string) =&gt; void) | undefined&#10;&#10;  constructor(&#10;    private readonly _connectId: string,&#10;    private readonly _userId: bigint,&#10;    private readonly _deviceId: string,&#10;  ) {}&#10;&#10;  sendAudioBase64(audioDataBase64: string, isLast = false): boolean {&#10;    if (!this._ws || !this._isReady) {&#10;      log.warn('[AsrApi] Not ready to send audio data')&#10;      return false&#10;    }&#10;    const audioData = Uint8Array.fromBase64(audioDataBase64)&#10;&#10;    let messageFlag: MessageFlagType&#10;    let currentSeq = this._sequenceNumber&#10;&#10;    if (isLast) {&#10;      messageFlag = MessageFlagType.negativeSequence&#10;      currentSeq = -this._sequenceNumber&#10;    } else {&#10;      messageFlag = MessageFlagType.positiveSequence&#10;      this._sequenceNumber++&#10;    }&#10;&#10;    this._ws.send(&#10;      serializeRequestMessage(&#10;        MessageType.audioOnlyRequest,&#10;        messageFlag,&#10;        SerializationType.none,&#10;        CompressionType.gzip,&#10;        currentSeq,&#10;        [audioData],&#10;      ),&#10;    )&#10;    return true&#10;  }&#10;&#10;  close() {&#10;    this._ws?.close()&#10;    this._isReady = false&#10;    this._sequenceNumber = 1&#10;  }&#10;&#10;  async connect(): Promise&lt;boolean&gt; {&#10;    if (this._connectionPromise) {&#10;      return this._connectionPromise&#10;    }&#10;&#10;    if (this._ws &amp;&amp; this._isReady) {&#10;      log.warn('[AsrApi] WebSocket is already connected')&#10;      return true&#10;    }&#10;&#10;    this._connectionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      this._ws = new WebSocket(&#10;        'wss://openspeech.bytedance.com/api/v3/sauc/bigmodel',&#10;        {&#10;          headers: {&#10;            'X-Api-Access-Key': process.env.ACCESS_TOKEN,&#10;            'X-Api-App-Key': process.env.APP_ID,&#10;            'X-Api-Resource-Id': 'volc.bigasr.sauc.duration',&#10;            'X-Api-Connect-Id': this._connectId,&#10;          },&#10;        },&#10;      )&#10;      this._ws.onclose = (event) =&gt; {&#10;        log.info(event, '[AsrApi] WebSocket closed')&#10;        this._isReady = false&#10;        this._sequenceNumber = 1&#10;        if (this._ws) {&#10;          this._ws.onopen = null&#10;          this._ws.onclose = null&#10;          this._ws = undefined&#10;        }&#10;        this._connectionPromise = null&#10;        resolve(false)&#10;      }&#10;      this._ws.onopen = () =&gt; {&#10;        this._ws?.send(&#10;          serializeRequestMessage(&#10;            MessageType.fullClientRequest,&#10;            MessageFlagType.positiveSequence,&#10;            SerializationType.none,&#10;            CompressionType.gzip,&#10;            this._sequenceNumber,&#10;            [createAsrRequestData(this._userId, this._deviceId)],&#10;          ),&#10;        )&#10;        this._sequenceNumber++&#10;        log.info('[AsrApi] WebSocket opened successfully')&#10;      }&#10;&#10;      if (!this._ws) {&#10;        log.error('[AsrApi] WebSocket is not initialized')&#10;        this._connectionPromise = null&#10;        resolve(false)&#10;        return&#10;      }&#10;&#10;      this._ws.onmessage = async (event) =&gt; {&#10;        try {&#10;          const message = parseResponseMessage(event.data.buffer)&#10;          if (message.responseType === ResponseType.errorResponse) {&#10;            log.warn(&#10;              {&#10;                errorType: message.errorType,&#10;                errorMessage: JSON.parse(message.errorMessage),&#10;              },&#10;              '[AsrApi] Error response',&#10;            )&#10;            this._isReady = false&#10;            this._connectionPromise = null&#10;            resolve(false)&#10;            return&#10;          }&#10;          if (message.responseType === ResponseType.ttsResponse) {&#10;            log.warn(&#10;              { responseType: message.responseType },&#10;              '[AsrApi] Received TTS response instead of ASR',&#10;            )&#10;            this._isReady = false&#10;            this._connectionPromise = null&#10;            resolve(false)&#10;            return&#10;          }&#10;&#10;          if (message.sequenceNumber === 1) {&#10;            log.info('[AsrApi] Configuration updated successfully')&#10;            this._isReady = true&#10;            resolve(true)&#10;          } else {&#10;            if (message.serializationType === SerializationType.json) {&#10;              const payload = message.data as {&#10;                result: { text: string }&#10;                utterances?: {&#10;                  definite: boolean&#10;                  start_time: number&#10;                  end_time: number&#10;                  text: string&#10;                  words: {&#10;                    start_time: number&#10;                    end_time: number&#10;                    text: string&#10;                  }[]&#10;                }[]&#10;              }&#10;              log.debug(&#10;                {&#10;                  text: payload.result.text,&#10;                  words: payload.utterances?.map(&#10;                    (utterance) =&gt; utterance.words,&#10;                  ),&#10;                },&#10;                '[AsrApi] Text data received',&#10;              )&#10;              if (message.messageFlag === MessageFlagType.negativeSequence) {&#10;                log.info(&#10;                  { text: payload.result.text },&#10;                  '[AsrApi] Recognition finished',&#10;                )&#10;                this.onFinish?.(payload.result.text)&#10;              }&#10;            } else {&#10;              log.info(&#10;                { length: message.data.byteLength },&#10;                '[AsrApi] Binary data received',&#10;              )&#10;            }&#10;          }&#10;        } catch (e) {&#10;          log.warn(e as Error, '[AsrApi] Failed to parse message')&#10;          this._isReady = false&#10;          this._connectionPromise = null&#10;          resolve(false)&#10;        }&#10;      }&#10;    })&#10;    return this._connectionPromise&#10;  }&#10;}&#10;&#10;export class TtsApi {&#10;  private _connectionPromise?: Promise&lt;boolean&gt;&#10;  private _connectionId?: string&#10;  private _startSessionPromise?: Promise&lt;boolean&gt;&#10;  private _sessionId?: string&#10;  private _onSessionStarted: ((sessionId: string) =&gt; void) | undefined&#10;  private _finishSessionPromise?: Promise&lt;boolean&gt;&#10;  private _onSessionFinished: (() =&gt; void) | undefined&#10;&#10;  private _voiceType = 'zh_female_tianmeixiaoyuan_moon_bigtts'&#10;  private _ws: WebSocket | undefined&#10;&#10;  onAudioData: ((audioData: Uint8Array) =&gt; void) | undefined&#10;  onFinish: (() =&gt; void) | undefined&#10;&#10;  constructor(&#10;    private readonly _connectId: string,&#10;    private readonly _userId: bigint,&#10;  ) {}&#10;&#10;  async startSession(): Promise&lt;boolean&gt; {&#10;    if (this._startSessionPromise) {&#10;      return this._startSessionPromise&#10;    }&#10;&#10;    if (this._ws &amp;&amp; this._connectionId?.length &amp;&amp; this._sessionId?.length) {&#10;      log.warn(&#10;        { sessionId: this._sessionId },&#10;        '[TtsApi] Session is already started',&#10;      )&#10;      return true&#10;    }&#10;    this._startSessionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      this._ws?.send(&#10;        serializeRequestMessage(&#10;          MessageType.fullClientRequest,&#10;          MessageFlagType.withEvent,&#10;          SerializationType.json,&#10;          CompressionType.none,&#10;          TtsEventType.startSession,&#10;          [&#10;            Bun.randomUUIDv7(),&#10;            createTtsRequestData(&#10;              this._userId,&#10;              TtsEventType.startSession,&#10;              this._voiceType,&#10;            ),&#10;          ],&#10;        ),&#10;      )&#10;      this._onSessionStarted = (sessionId: string) =&gt; {&#10;        this._sessionId = sessionId&#10;        resolve(true)&#10;        this._onSessionStarted = undefined&#10;      }&#10;    })&#10;&#10;    return this._startSessionPromise&#10;  }&#10;&#10;  async finishSession(): Promise&lt;boolean&gt; {&#10;    if (this._finishSessionPromise) {&#10;      return this._finishSessionPromise&#10;    }&#10;&#10;    this._finishSessionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      if (&#10;        !this._ws ||&#10;        !this._connectionId?.length ||&#10;        !this._sessionId?.length&#10;      ) {&#10;        log.warn('[TtsApi] Session is already finished or not started')&#10;        resolve(true)&#10;        return&#10;      }&#10;&#10;      this._ws.send(&#10;        serializeRequestMessage(&#10;          MessageType.fullClientRequest,&#10;          MessageFlagType.withEvent,&#10;          SerializationType.json,&#10;          CompressionType.none,&#10;          TtsEventType.finishSession,&#10;          [this._sessionId, {}],&#10;        ),&#10;      )&#10;      this._onSessionFinished = () =&gt; {&#10;        this._sessionId = undefined&#10;        resolve(true)&#10;        this._onSessionFinished = undefined&#10;      }&#10;      return true&#10;    })&#10;&#10;    return this._finishSessionPromise&#10;  }&#10;&#10;  sendText(text: string): boolean {&#10;    if (!this._ws || !this._connectionId?.length || !this._sessionId?.length) {&#10;      log.warn('[TtsApi] Is not ready to send text')&#10;      return false&#10;    }&#10;&#10;    this._ws.send(&#10;      serializeRequestMessage(&#10;        MessageType.fullClientRequest,&#10;        MessageFlagType.withEvent,&#10;        SerializationType.json,&#10;        CompressionType.none,&#10;        TtsEventType.taskRequest,&#10;        [&#10;          this._sessionId,&#10;          createTtsRequestData(&#10;            this._userId,&#10;            TtsEventType.taskRequest,&#10;            this._voiceType,&#10;            text,&#10;          ),&#10;        ],&#10;      ),&#10;    )&#10;    return true&#10;  }&#10;&#10;  close() {&#10;    this._ws?.close()&#10;  }&#10;&#10;  async connect(): Promise&lt;boolean&gt; {&#10;    if (this._connectionPromise) {&#10;      return this._connectionPromise&#10;    }&#10;&#10;    if (this._ws &amp;&amp; this._connectionId?.length) {&#10;      log.warn('[TtsApi] WebSocket is already connected')&#10;      return true&#10;    }&#10;&#10;    this._connectionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      this._ws = new WebSocket(&#10;        'wss://openspeech.bytedance.com/api/v3/tts/bidirection',&#10;        {&#10;          headers: {&#10;            'X-Api-Access-Key': process.env.ACCESS_TOKEN,&#10;            'X-Api-App-Key': process.env.APP_ID,&#10;            'X-Api-Resource-Id': 'volc.service_type.10029',&#10;            'X-Api-Connect-Id': this._connectId,&#10;          },&#10;        },&#10;      )&#10;      if (!this._ws) {&#10;        log.error('[TtsApi] WebSocket is not initialized')&#10;        this._connectionPromise = undefined&#10;        resolve(false)&#10;        return&#10;      }&#10;&#10;      this._ws.onclose = (event) =&gt; {&#10;        log.warn(event, '[TtsApi] WebSocket closed')&#10;        this._connectionPromise = undefined&#10;        this._connectionId = undefined&#10;        this._startSessionPromise = undefined&#10;        this._sessionId = undefined&#10;&#10;        this._onSessionStarted = undefined&#10;        if (this._ws) {&#10;          this._ws.onopen = null&#10;          this._ws.onclose = null&#10;          this._ws = undefined&#10;        }&#10;&#10;        resolve(false)&#10;      }&#10;      this._ws.onopen = () =&gt; {&#10;        this._ws?.send(&#10;          serializeRequestMessage(&#10;            MessageType.fullClientRequest,&#10;            MessageFlagType.withEvent,&#10;            SerializationType.json,&#10;            CompressionType.none,&#10;            TtsEventType.startConnection,&#10;            [{}],&#10;          ),&#10;        )&#10;        log.info('[TtsApi] WebSocket opened successfully')&#10;      }&#10;      this._ws.onmessage = async (event) =&gt; {&#10;        try {&#10;          const message = parseResponseMessage(event.data.buffer)&#10;&#10;          if (message.responseType === ResponseType.errorResponse) {&#10;            log.warn(&#10;              {&#10;                errorType: message.errorType,&#10;                errorMessage: JSON.parse(message.errorMessage),&#10;              },&#10;              '[TtsApi] Error response',&#10;            )&#10;            this.close()&#10;            resolve(false)&#10;            return&#10;          }&#10;          if (message.responseType === ResponseType.asrResponse) {&#10;            log.warn(&#10;              { responseType: message.responseType },&#10;              '[TtsApi] Received ASR response instead of TTS',&#10;            )&#10;            this.close()&#10;            resolve(false)&#10;            return&#10;          }&#10;&#10;          switch (message.eventType) {&#10;            case TtsEventType.connectionStarted: {&#10;              log.info({ connectionId: message.id }, '[TtsApi] Connection started')&#10;              this._connectionId = message.id&#10;              resolve(true)&#10;              break&#10;            }&#10;            case TtsEventType.sessionStarted: {&#10;              log.info({ sessionId: message.id }, '[TtsApi] Session started')&#10;              this._onSessionStarted?.(message.id)&#10;              break&#10;            }&#10;            case TtsEventType.sessionFinished: {&#10;              log.info({ sessionId: this._sessionId }, '[TtsApi] Session finished')&#10;              this._onSessionFinished?.()&#10;              this.onFinish?.()&#10;              break&#10;            }&#10;            case TtsEventType.ttsSentenceStart: {&#10;              log.info({ sessionId: this._sessionId }, '[TtsApi] Sentence started')&#10;              break&#10;            }&#10;            case TtsEventType.ttsSentenceEnd: {&#10;              log.info({ sessionId: this._sessionId }, '[TtsApi] Sentence ended')&#10;              break&#10;            }&#10;            case TtsEventType.ttsResponse: {&#10;              if (!(message.data instanceof Uint8Array)) {&#10;                log.warn(&#10;                  message,&#10;                  '[TtsApi] Received ttsResponse with unsupported data type',&#10;                )&#10;                this.close()&#10;                resolve(false)&#10;                return&#10;              }&#10;              this.onAudioData?.(message.data)&#10;              break&#10;            }&#10;            default: {&#10;              log.warn(message, '[TtsApi] Received unsupported TTS event type')&#10;              this.close()&#10;              resolve(false)&#10;              return&#10;            }&#10;          }&#10;        } catch (e) {&#10;          log.warn(e as Error, '[TtsApi] Failed to parse TTS message')&#10;          this.close()&#10;          resolve(false)&#10;        }&#10;      }&#10;    })&#10;&#10;    return this._connectionPromise&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { log } from '@log'&#10;&#10;import {&#10;  CompressionType,&#10;  MessageFlagType,&#10;  MessageType,&#10;  ResponseType,&#10;  SerializationType,&#10;  TtsEventType,&#10;} from './types'&#10;import {&#10;  createAsrRequestData,&#10;  createTtsRequestData,&#10;  parseResponseMessage,&#10;  serializeRequestMessage,&#10;} from './utils'&#10;&#10;export class AsrApi {&#10;  private _connectionPromise: Promise&lt;boolean&gt; | null = null&#10;  private _isReady = false&#10;  private _sequenceNumber = 1&#10;  private _ws: WebSocket | undefined&#10;&#10;  onFinish: ((recognized: string) =&gt; void) | undefined&#10;&#10;  constructor(&#10;    private readonly _connectId: string,&#10;    private readonly _userId: bigint,&#10;    private readonly _deviceId: string,&#10;  ) {}&#10;&#10;  sendAudioBase64(audioDataBase64: string, isLast = false): boolean {&#10;    if (!this._ws || !this._isReady) {&#10;      log.warn('[AsrApi] Not ready to send audio data')&#10;      return false&#10;    }&#10;    const audioData = Uint8Array.fromBase64(audioDataBase64)&#10;&#10;    let messageFlag: MessageFlagType&#10;    let currentSeq = this._sequenceNumber&#10;&#10;    if (isLast) {&#10;      messageFlag = MessageFlagType.negativeSequence&#10;      currentSeq = -this._sequenceNumber&#10;    } else {&#10;      messageFlag = MessageFlagType.positiveSequence&#10;      this._sequenceNumber++&#10;    }&#10;&#10;    this._ws.send(&#10;      serializeRequestMessage(&#10;        MessageType.audioOnlyRequest,&#10;        messageFlag,&#10;        SerializationType.none,&#10;        CompressionType.gzip,&#10;        currentSeq,&#10;        [audioData],&#10;      ),&#10;    )&#10;    return true&#10;  }&#10;&#10;  close() {&#10;    this._ws?.close()&#10;    this._isReady = false&#10;    this._sequenceNumber = 1&#10;  }&#10;&#10;  async connect(): Promise&lt;boolean&gt; {&#10;    if (this._connectionPromise) {&#10;      return this._connectionPromise&#10;    }&#10;&#10;    if (this._ws &amp;&amp; this._isReady) {&#10;      log.warn('[AsrApi] WebSocket is already connected')&#10;      return true&#10;    }&#10;&#10;    this._connectionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      this._ws = new WebSocket(&#10;        'wss://openspeech.bytedance.com/api/v3/sauc/bigmodel',&#10;        {&#10;          headers: {&#10;            'X-Api-Access-Key': process.env.ACCESS_TOKEN,&#10;            'X-Api-App-Key': process.env.APP_ID,&#10;            'X-Api-Resource-Id': 'volc.bigasr.sauc.duration',&#10;            'X-Api-Connect-Id': this._connectId,&#10;          },&#10;        },&#10;      )&#10;      this._ws.onclose = (event) =&gt; {&#10;        log.info(event, '[AsrApi] WebSocket closed')&#10;        this._isReady = false&#10;        this._sequenceNumber = 1&#10;        if (this._ws) {&#10;          this._ws.onopen = null&#10;          this._ws.onclose = null&#10;          this._ws = undefined&#10;        }&#10;        this._connectionPromise = null&#10;        resolve(false)&#10;      }&#10;      this._ws.onopen = () =&gt; {&#10;        this._ws?.send(&#10;          serializeRequestMessage(&#10;            MessageType.fullClientRequest,&#10;            MessageFlagType.positiveSequence,&#10;            SerializationType.none,&#10;            CompressionType.gzip,&#10;            this._sequenceNumber,&#10;            [createAsrRequestData(this._userId, this._deviceId)],&#10;          ),&#10;        )&#10;        this._sequenceNumber++&#10;        log.info('[AsrApi] WebSocket opened successfully')&#10;      }&#10;&#10;      if (!this._ws) {&#10;        log.error('[AsrApi] WebSocket is not initialized')&#10;        this._connectionPromise = null&#10;        resolve(false)&#10;        return&#10;      }&#10;&#10;      this._ws.onmessage = async (event) =&gt; {&#10;        try {&#10;          const message = parseResponseMessage(event.data.buffer)&#10;          if (message.responseType === ResponseType.errorResponse) {&#10;            log.warn(&#10;              {&#10;                errorType: message.errorType,&#10;                errorMessage: JSON.parse(message.errorMessage),&#10;              },&#10;              '[AsrApi] Error response',&#10;            )&#10;            this._isReady = false&#10;            this._connectionPromise = null&#10;            resolve(false)&#10;            return&#10;          }&#10;          if (message.responseType === ResponseType.ttsResponse) {&#10;            log.warn(&#10;              { responseType: message.responseType },&#10;              '[AsrApi] Received TTS response instead of ASR',&#10;            )&#10;            this._isReady = false&#10;            this._connectionPromise = null&#10;            resolve(false)&#10;            return&#10;          }&#10;&#10;          if (message.sequenceNumber === 1) {&#10;            log.info('[AsrApi] Configuration updated successfully')&#10;            this._isReady = true&#10;            resolve(true)&#10;          } else {&#10;            if (message.serializationType === SerializationType.json) {&#10;              const payload = message.data as {&#10;                result: { text: string }&#10;                utterances?: {&#10;                  definite: boolean&#10;                  start_time: number&#10;                  end_time: number&#10;                  text: string&#10;                  words: {&#10;                    start_time: number&#10;                    end_time: number&#10;                    text: string&#10;                  }[]&#10;                }[]&#10;              }&#10;              log.debug(&#10;                {&#10;                  text: payload.result.text,&#10;                  words: payload.utterances?.map(&#10;                    (utterance) =&gt; utterance.words,&#10;                  ),&#10;                },&#10;                '[AsrApi] Text data received',&#10;              )&#10;              if (message.messageFlag === MessageFlagType.negativeSequence) {&#10;                log.info(&#10;                  { text: payload.result.text },&#10;                  '[AsrApi] Recognition finished',&#10;                )&#10;                this.onFinish?.(payload.result.text)&#10;              }&#10;            } else {&#10;              log.info(&#10;                { length: message.data.byteLength },&#10;                '[AsrApi] Binary data received',&#10;              )&#10;            }&#10;          }&#10;        } catch (e) {&#10;          log.warn(e as Error, '[AsrApi] Failed to parse message')&#10;          this._isReady = false&#10;          this._connectionPromise = null&#10;          resolve(false)&#10;        }&#10;      }&#10;    })&#10;    return this._connectionPromise&#10;  }&#10;}&#10;&#10;export class TtsApi {&#10;  private _connectionPromise?: Promise&lt;boolean&gt;&#10;  private _connectionId?: string&#10;  private _startSessionPromise?: Promise&lt;boolean&gt;&#10;  private _sessionId?: string&#10;  private _onSessionStarted: ((sessionId: string) =&gt; void) | undefined&#10;  private _finishSessionPromise?: Promise&lt;boolean&gt;&#10;  private _onSessionFinished: (() =&gt; void) | undefined&#10;&#10;  private _voiceType = 'zh_female_tianmeixiaoyuan_moon_bigtts'&#10;  private _ws: WebSocket | undefined&#10;&#10;  onAudioData: ((audioData: Uint8Array) =&gt; void) | undefined&#10;  onFinish: (() =&gt; void) | undefined&#10;&#10;  constructor(&#10;    private readonly _connectId: string,&#10;    private readonly _userId: bigint,&#10;  ) {}&#10;&#10;  async startSession(): Promise&lt;boolean&gt; {&#10;    if (this._startSessionPromise) {&#10;      return this._startSessionPromise&#10;    }&#10;&#10;    if (this._ws &amp;&amp; this._connectionId?.length &amp;&amp; this._sessionId?.length) {&#10;      log.warn(&#10;        { sessionId: this._sessionId },&#10;        '[TtsApi] Session is already started',&#10;      )&#10;      return true&#10;    }&#10;    this._startSessionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      this._ws?.send(&#10;        serializeRequestMessage(&#10;          MessageType.fullClientRequest,&#10;          MessageFlagType.withEvent,&#10;          SerializationType.json,&#10;          CompressionType.none,&#10;          TtsEventType.startSession,&#10;          [&#10;            Bun.randomUUIDv7(),&#10;            createTtsRequestData(&#10;              this._userId,&#10;              TtsEventType.startSession,&#10;              this._voiceType,&#10;            ),&#10;          ],&#10;        ),&#10;      )&#10;      this._onSessionStarted = (sessionId: string) =&gt; {&#10;        this._sessionId = sessionId&#10;        resolve(true)&#10;        this._onSessionStarted = undefined&#10;      }&#10;    })&#10;&#10;    return this._startSessionPromise&#10;  }&#10;&#10;  async finishSession(): Promise&lt;boolean&gt; {&#10;    if (this._finishSessionPromise) {&#10;      return this._finishSessionPromise&#10;    }&#10;&#10;    this._finishSessionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      if (&#10;        !this._ws ||&#10;        !this._connectionId?.length ||&#10;        !this._sessionId?.length&#10;      ) {&#10;        log.warn('[TtsApi] Session is already finished or not started')&#10;        resolve(true)&#10;        return&#10;      }&#10;&#10;      this._ws.send(&#10;        serializeRequestMessage(&#10;          MessageType.fullClientRequest,&#10;          MessageFlagType.withEvent,&#10;          SerializationType.json,&#10;          CompressionType.none,&#10;          TtsEventType.finishSession,&#10;          [this._sessionId, {}],&#10;        ),&#10;      )&#10;      this._onSessionFinished = () =&gt; {&#10;        this._sessionId = undefined&#10;        resolve(true)&#10;        this._onSessionFinished = undefined&#10;      }&#10;      return true&#10;    })&#10;&#10;    return this._finishSessionPromise&#10;  }&#10;&#10;  sendText(text: string): boolean {&#10;    if (!this._ws || !this._connectionId?.length || !this._sessionId?.length) {&#10;      log.warn('[TtsApi] Is not ready to send text')&#10;      return false&#10;    }&#10;&#10;    this._ws.send(&#10;      serializeRequestMessage(&#10;        MessageType.fullClientRequest,&#10;        MessageFlagType.withEvent,&#10;        SerializationType.json,&#10;        CompressionType.none,&#10;        TtsEventType.taskRequest,&#10;        [&#10;          this._sessionId,&#10;          createTtsRequestData(&#10;            this._userId,&#10;            TtsEventType.taskRequest,&#10;            this._voiceType,&#10;            text,&#10;          ),&#10;        ],&#10;      ),&#10;    )&#10;    return true&#10;  }&#10;&#10;  close() {&#10;    this._ws?.close()&#10;  }&#10;&#10;  async connect(): Promise&lt;boolean&gt; {&#10;    if (this._connectionPromise) {&#10;      return this._connectionPromise&#10;    }&#10;&#10;    if (this._ws &amp;&amp; this._connectionId?.length) {&#10;      log.warn('[TtsApi] WebSocket is already connected')&#10;      return true&#10;    }&#10;&#10;    this._connectionPromise = new Promise&lt;boolean&gt;((resolve) =&gt; {&#10;      this._ws = new WebSocket(&#10;        'wss://openspeech.bytedance.com/api/v3/tts/bidirection',&#10;        {&#10;          headers: {&#10;            'X-Api-Access-Key': process.env.ACCESS_TOKEN,&#10;            'X-Api-App-Key': process.env.APP_ID,&#10;            'X-Api-Resource-Id': 'volc.service_type.10029',&#10;            'X-Api-Connect-Id': this._connectId,&#10;          },&#10;        },&#10;      )&#10;      if (!this._ws) {&#10;        log.error('[TtsApi] WebSocket is not initialized')&#10;        this._connectionPromise = undefined&#10;        resolve(false)&#10;        return&#10;      }&#10;&#10;      this._ws.onclose = (event) =&gt; {&#10;        log.warn(event, '[TtsApi] WebSocket closed')&#10;        this._connectionPromise = undefined&#10;        this._connectionId = undefined&#10;        this._startSessionPromise = undefined&#10;        this._sessionId = undefined&#10;&#10;        this._onSessionStarted = undefined&#10;        if (this._ws) {&#10;          this._ws.onopen = null&#10;          this._ws.onclose = null&#10;          this._ws = undefined&#10;        }&#10;&#10;        resolve(false)&#10;      }&#10;      this._ws.onopen = () =&gt; {&#10;        this._ws?.send(&#10;          serializeRequestMessage(&#10;            MessageType.fullClientRequest,&#10;            MessageFlagType.withEvent,&#10;            SerializationType.json,&#10;            CompressionType.none,&#10;            TtsEventType.startConnection,&#10;            [{}],&#10;          ),&#10;        )&#10;        log.info('[TtsApi] WebSocket opened successfully')&#10;      }&#10;      this._ws.onmessage = async (event) =&gt; {&#10;        try {&#10;          const message = parseResponseMessage(event.data.buffer)&#10;&#10;          if (message.responseType === ResponseType.errorResponse) {&#10;            log.warn(&#10;              {&#10;                errorType: message.errorType,&#10;                errorMessage: JSON.parse(message.errorMessage),&#10;              },&#10;              '[TtsApi] Error response',&#10;            )&#10;            this.close()&#10;            resolve(false)&#10;            return&#10;          }&#10;          if (message.responseType === ResponseType.asrResponse) {&#10;            log.warn(&#10;              { responseType: message.responseType },&#10;              '[TtsApi] Received ASR response instead of TTS',&#10;            )&#10;            this.close()&#10;            resolve(false)&#10;            return&#10;          }&#10;&#10;          switch (message.eventType) {&#10;            case TtsEventType.connectionStarted: {&#10;              log.info({ connectionId: message.id }, '[TtsApi] Connection started')&#10;              this._connectionId = message.id&#10;              resolve(true)&#10;              break&#10;            }&#10;            case TtsEventType.sessionStarted: {&#10;              log.info({ sessionId: message.id }, '[TtsApi] Session started')&#10;              this._onSessionStarted?.(message.id)&#10;              break&#10;            }&#10;            case TtsEventType.sessionFinished: {&#10;              log.info({ sessionId: this._sessionId }, '[TtsApi] Session finished')&#10;              this._onSessionFinished?.()&#10;              this.onFinish?.()&#10;              break&#10;            }&#10;            case TtsEventType.ttsSentenceStart: {&#10;              log.info({ sessionId: this._sessionId }, '[TtsApi] Sentence started')&#10;              break&#10;            }&#10;            case TtsEventType.ttsSentenceEnd: {&#10;              log.info({ sessionId: this._sessionId }, '[TtsApi] Sentence ended')&#10;              break&#10;            }&#10;            case TtsEventType.ttsResponse: {&#10;              if (!(message.data instanceof Uint8Array)) {&#10;                log.warn(&#10;                  message,&#10;                  '[TtsApi] Received ttsResponse with unsupported data type',&#10;                )&#10;                this.close()&#10;                resolve(false)&#10;                return&#10;              }&#10;              this.onAudioData?.(message.data)&#10;              break&#10;            }&#10;            default: {&#10;              log.warn(message, '[TtsApi] Received unsupported TTS event type')&#10;              this.close()&#10;              resolve(false)&#10;              return&#10;            }&#10;          }&#10;        } catch (e) {&#10;          log.warn(e as Error, '[TtsApi] Failed to parse TTS message')&#10;          this.close()&#10;          resolve(false)&#10;        }&#10;      }&#10;    })&#10;&#10;    return this._connectionPromise&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>